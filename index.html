<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Interactive 1-min Chart — Entry / Exit Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.plot.ly/plotly-2.34.0.min.js"></script>
  <style>
    body { font-family: Arial, Helvetica, sans-serif; margin:18px; }
    .controls { margin-bottom:8px; }
    button { margin-right:8px; padding:8px 12px; border-radius:6px; cursor:pointer; }
    #chart { width:100%; height:620px; }
    .note { font-size:13px; color:#444; margin-top:10px; }
    input[type=file]{display:none;}
    .btn-file { padding:8px 12px; border-radius:6px; background:#eee; display:inline-block; cursor:pointer; margin-right:8px; }
  </style>
</head>
<body>

  <h3>1-min Price Chart — Entry / Exit demo</h3>

  <div class="controls">
    <button id="load-sample">Load sample chart</button>
    <label class="btn-file" id="label-load-csv">Load local CSV</label>
    <input id="csv-file" type="file" accept=".csv,text/csv"/>
    <button id="export-png">Export PNG</button>
  </div>

  <div id="chart"></div>

  <p class="note">
    <strong>CSV format:</strong> datetime,open,high,low,close,volume (datetime ISO or "YYYY-MM-DD HH:mm").<br>
    Example first row: <code>2025-11-21 09:15,100.5,101.2,100.4,100.9,1200</code><br>
    When you load CSV the chart recalculates EMAs and keeps entry/exit markers. 
  </p>

<script>
/* --------------------------
   Utility: EMA function
   -------------------------- */
function ema(values, period) {
  const k = 2 / (period + 1);
  const out = [];
  let prev;
  for (let i=0;i<values.length;i++){
    const v = values[i];
    if (i===0) {
      prev = v;
      out.push(v);
    } else {
      const cur = v * k + prev * (1 - k);
      out.push(cur);
      prev = cur;
    }
  }
  return out;
}

/* --------------------------
   Generate synthetic 1-min sample OHLC data
   -------------------------- */
function generateSampleData(points = 300, startPrice = 100) {
  const data = [];
  const start = new Date();
  // set start time to recent hours and roll backwards so chart looks left-to-right
  start.setMinutes(start.getMinutes() - points);
  let price = startPrice;
  for (let i=0;i<points;i++){
    const t = new Date(start.getTime() + i*60000); // +1 minute
    // random walk
    const open = price;
    const change = (Math.random() - 0.45) * 0.7; // tweak volatility
    price = +(price + change).toFixed(4);
    const close = price;
    const high = Math.max(open, close) + Math.random()*0.2;
    const low = Math.min(open, close) - Math.random()*0.2;
    const volume = Math.round(200 + Math.random()*1200);
    data.push({
      datetime: t.toISOString().slice(0,19).replace('T',' '),
      open: +open.toFixed(4),
      high: +high.toFixed(4),
      low: +low.toFixed(4),
      close: +close.toFixed(4),
      volume
    });
  }
  return data;
}

/* --------------------------
   Convert records -> Plotly traces
   -------------------------- */
function buildTracesFromOHLC(records) {
  const x = records.map(r=>r.datetime);
  const open = records.map(r=>r.open);
  const high = records.map(r=>r.high);
  const low = records.map(r=>r.low);
  const close = records.map(r=>r.close);
  const volume = records.map(r=>r.volume);

  // compute EMAs from close
  const ema9 = ema(close, 9);
  const ema20 = ema(close, 20);

  const candle = {
    x, open, high, low, close,
    increasing: {line: {color: '#26a69a'}},
    decreasing: {line: {color: '#ef5350'}},
    hoverinfo:'x+open+high+low+close',
    type: 'candlestick',
    name: 'Price'
  };

  const ema9Trace = { x, y: ema9, mode:'lines', name:'EMA 9', line:{width:1.6, dash:'solid'}, hoverinfo:'x+y' };
  const ema20Trace = { x, y: ema20, mode:'lines', name:'EMA 20', line:{width:1.6, dash:'dot'}, hoverinfo:'x+y' };

  const volTrace = {
    x, y: volume, yaxis:'y2', type:'bar', marker:{opacity:0.5}, name:'Volume'
  };

  return { candle, ema9Trace, ema20Trace, volTrace, close };
}

/* --------------------------
   Example entry/exit logic (for demo)
   - Find a 9EMA rejection bullish entry: when price dips to EMA9 and then next candle closes above
   - We'll mark one example entry & TP and place a stop-loss a bit below entry
   -------------------------- */
function findExampleEntry(records, ema9) {
  // naive: find the earliest index where low <= ema9 and next close > ema9
  for (let i=1;i<records.length-3;i++){
    const low = records[i].low;
    const nextClose = records[i+1].close;
    if (low <= ema9[i] && nextClose > ema9[i]) {
      // entry price: next candle open (simulated)
      const entryIndex = i+1;
      const entryPrice = records[entryIndex].open;
      const takeProfit = +(entryPrice * 1.0125).toFixed(4); // +1.25% TP for demo
      const stopLoss = +(entryPrice * 0.995).toFixed(4); // -0.5% stop
      return { entryIndex, entryPrice, takeProfit, stopLoss };
    }
  }
  return null;
}

/* --------------------------
   Draw/refresh Plotly chart
   -------------------------- */
let currentRecords = [];
let lastLayout = null;
function renderChart(records) {
  const built = buildTracesFromOHLC(records);
  const candle = built.candle;
  const ema9Trace = built.ema9Trace;
  const ema20Trace = built.ema20Trace;
  const volTrace = built.volTrace;

  // detect example entry
  const ema9values = ema(records.map(r=>r.close), 9);
  const found = findExampleEntry(records, ema9values);

  // markers array
  const markers = [];
  const shapes = [];
  if (found) {
    const xEntry = records[found.entryIndex].datetime;
    // entry marker
    markers.push({
      x: xEntry,
      y: found.entryPrice,
      text: 'ENTRY',
      hovertext:`ENTRY @ ${found.entryPrice}`,
      marker: { color: '#00cc66', size: 12, symbol: 'triangle-up' },
      name:'Entry',
      type:'scatter',
      mode:'markers+text',
      textposition:'top center'
    });
    // TP marker: place at time where price first reaches TP after entry (search forward)
    let tpIndex = null;
    for (let j=found.entryIndex; j<records.length; j++){
      if (records[j].high >= found.takeProfit) { tpIndex = j; break; }
    }
    const xTP = tpIndex ? records[tpIndex].datetime : records[records.length-1].datetime;
    const tpY = found.takeProfit;
    markers.push({
      x: xTP, y: tpY, text:'TP', hovertext:`TP @ ${tpY}`, mode:'markers+text',
      marker:{color:'#1e88e5', size:11, symbol:'circle'}, textposition:'bottom center', type:'scatter', name:'TP'
    });

    // shaded stop-loss rectangle (draw from entry time to end or TP time)
    const rectX0 = xEntry;
    const rectX1 = tpIndex ? records[tpIndex].datetime : records[records.length-1].datetime;
    shapes.push({
      type: 'rect',
      xref: 'x',
      yref: 'y',
      x0: rectX0,
      x1: rectX1,
      y0: found.stopLoss,
      y1: found.entryPrice,
      fillcolor: 'rgba(255,80,80,0.12)',
      line: {width:0},
      layer:'below'
    });

    // also add a horizontal line at stop-loss and entry for clarity
    shapes.push({
      type:'line',
      xref:'paper', x0:0, x1:1,
      yref:'y', y0:found.stopLoss, y1:found.stopLoss,
      line:{color:'rgba(255,80,80,0.6)', width:1, dash:'dash'}
    });
    shapes.push({
      type:'line',
      xref:'paper', x0:0, x1:1,
      yref:'y', y0:found.entryPrice, y1:found.entryPrice,
      line:{color:'rgba(0,180,100,0.6)', width:1, dash:'dot'}
    });
  }

  // layout
  const layout = {
    showlegend: true,
    legend: { orientation: 'h', x:0.02, y:1.06 },
    margin: { t:40, r:40, l:60, b:40 },
    xaxis: { rangeslider: { visible: false }, type:'category' },
    yaxis: { domain: [0.22, 1], title:'Price' },
    yaxis2: { domain: [0, 0.2], title:'Volume', anchor:'x' },
    shapes: shapes,
    hovermode:'x unified'
  };

  const data = [candle, ema9Trace, ema20Trace, volTrace];

  // overlay markers as additional scatter traces (if any)
  if (markers.length) {
    markers.forEach(m => data.push(m));
  }

  const config = { responsive:true, displayModeBar:true };

  Plotly.react('chart', data, layout, config).then(() => {
    currentRecords = records;
    lastLayout = layout;
  });
}

/* --------------------------
   CSV parsing
   -------------------------- */
function parseCSVtext(text) {
  // simple CSV parse (expects header)
  const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
  if (!lines.length) return [];
  const header = lines[0].split(',').map(h=>h.trim().toLowerCase());
  const idx = h => header.indexOf(h) >= 0 ? header.indexOf(h) : -1;
  const di = idx('datetime') !== -1 ? idx('datetime') : 0;
  const oi = idx('open') !== -1 ? idx('open') : 1;
  const hi = idx('high') !== -1 ? idx('high') : 2;
  const li = idx('low') !== -1 ? idx('low') : 3;
  const ci = idx('close') !== -1 ? idx('close') : 4;
  const vi = idx('volume') !== -1 ? idx('volume') : 5;

  const records = [];
  for (let i=1;i<lines.length;i++){
    const cols = lines[i].split(',').map(c=>c.trim());
    if (cols.length < 5) continue;
    const r = {
      datetime: cols[di] || cols[0],
      open: parseFloat(cols[oi]),
      high: parseFloat(cols[hi]),
      low: parseFloat(cols[li]),
      close: parseFloat(cols[ci]),
      volume: vi>=0 ? parseFloat(cols[vi]) : 0
    };
    if (!isNaN(r.open) && !isNaN(r.close)) records.push(r);
  }
  return records;
}

/* --------------------------
   Wire up buttons
   -------------------------- */
document.getElementById('load-sample').addEventListener('click', ()=> {
  const sample = generateSampleData(420, 100 + (Math.random()*4-2));
  renderChart(sample);
});

// CSV input
const csvInput = document.getElementById('csv-file');
document.getElementById('label-load-csv').addEventListener('click', ()=> csvInput.click());
csvInput.addEventListener('change', (ev)=>{
  const f = ev.target.files && ev.target.files[0];
  if (!f) return;
  const reader = new FileReader();
  reader.onload = function(e){
    const text = e.target.result;
    const records = parseCSVtext(text);
    if (!records.length) {
      alert('No valid rows found in CSV. Make sure header includes datetime,open,high,low,close.');
      return;
    }
    renderChart(records);
  };
  reader.readAsText(f);
});

// export PNG
document.getElementById('export-png').addEventListener('click', ()=>{
  const chartDiv = document.getElementById('chart');
  Plotly.toImage(chartDiv, {format:'png', width:1400, height:800}).then((dataUrl)=>{
    // trigger download
    const a = document.createElement('a');
    a.href = dataUrl;
    a.download = 'chart-entry-exit.png';
    document.body.appendChild(a);
    a.click();
    a.remove();
  }).catch(err => { console.error(err); alert('Export failed: '+err.message); });
});

// auto-load sample on open
document.addEventListener('DOMContentLoaded', ()=> {
  const sample = generateSampleData(420, 100 + (Math.random()*4-2));
  renderChart(sample);
});
</script>
</body>
</html>